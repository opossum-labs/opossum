<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>OPOSSUM Handbook</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">OPOSSUM Handbook</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This book represents the project documentation of OPOSSUM (<strong>OP</strong>en <strong>S</strong>ource <strong>O</strong>ptics <strong>S</strong>imulation <strong>S</strong>ystem and <strong>U</strong>nified <strong>M</strong>odeller). The goal of this project is the development of a common software platform for simulating various aspects of optical systems in a holistic approach. It should be particularly useful for simulating and designing large-size, high-energy / intensity laser systems.</p>
<p>While there are a plethora of, mostly commercial, simulation / calculation tools available, most of them only address specific aspects of an optical system. For example, there are tools for pure geometric optics (raytracing), the simulation of non-linear effects in materials, wavefront propagation, parasitic lasing, diffuse illumination / straylight simulation etc... Modern laser systems need to take all these aspects into account which requires a repeated change of the tools and / or remodeling the optical system. This project is an approach to unifying this design workflow.</p>
<p>This project is a task within the <strong>THRILL</strong> project. The <strong>THRILL</strong> acronym stands for <strong>T</strong>echnology for <strong>H</strong>igh-<strong>R</strong>epetition-rate <strong>I</strong>ntense <strong>L</strong>aser <strong>L</strong>aboratories and is a project funded by the European Union.</p>
<p>Within the <strong>THRILL</strong> project, this task (3.4) has the title "supporting calculations for system design" and is led by GSI. The task description from the proposal is as follows:</p>
<blockquote>
<p>[...] To strengthen the design decisions and later benchmark the system performance, the use of theoretical modelling is of vital
importance. It exists a number of simulation tools for certain aspects of the laser chain (broadband generation, nonlinear
frequency conversion and amplification, laser amplification, dispersion management, wavefront propagation, calculation of parasitic
lasing, etc.) distributed among the project partners (GSI, FZU/ELI-BL, HZDR, CNRS-LULI) and in the wider community. In this task,
we will gather calculations with the aim to make them accessible to the partners as well as to the wider community. For this
purpose a common platform for input and output formats possibly with suitable interfaces will be developed. [...]</p>
</blockquote>
<p>The project has a funding period of four years. The more specific goals and the project structure will be discussed in the following.</p>
<p><em>Note</em>: This documentation will most probably never be a <em>finished</em> document but continuously extended and modified with the progression of the project.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="project-goals"><a class="header" href="#project-goals">Project Goals</a></h1>
<p>Before defining the project goals, let us first look at the current situation while designing laser systems.</p>
<h2 id="current-issues"><a class="header" href="#current-issues">Current Issues</a></h2>
<p>As stated in the introduction, the design of complex high-energy / intensity laser systems requires a detailed simulation of optical (and of course mechanical) effects and aspects. Often, these aspects have to be simultaneously taken into account while optimizing a system design. Different aspects might even stand against each other, such that optimizing (e.g. maximizing/ minimizing) one effect degrades the performance of other system parameters. So, a holistic approach would be desirable.</p>
<p>In the past, many tools were developed, often addressing very particular optical effects at several companies and research institutes. Often these tools are only used at the institutions which developed the software and even there only used by one or two people (e.g. in the frame of a master or PhD thesis). This of course sometimes leads to the situation that different institutes repeat the work and "reinvent the wheel". Hence, a common set of tools accompanied by proper knowledge exchange would significantly reduce this inefficiency.</p>
<p>Besides the solutions for modelling particular aspects of optical systems, there are many more general-purpose tools on the market which are unfortunately commercial, closed-source solutions. Each software has its own underlying design strategy. Furthermore, many of these tools (e.g. ZEMAX, OSLO, etc.) are designed for simulating more "traditional" optical systems such as camera objectives or illumination setups. In contrast, laser (chain) systems often demand different features which are not always fully supported (or easy to model) by these software packages.</p>
<p>The usage of different tools during the design phase often requires repeatedly modelling the optical system in the particular software and providing a bunch of input parameters. A common platform would allow for modelling the desired system once and analysing it with the above-mentioned tools and providing the input data in the particular format.</p>
<h2 id="goals"><a class="header" href="#goals">Goals</a></h2>
<p>Based on the current situation discussed above the project tries to address the following goals:</p>
<ul>
<li>Improve the knowledge exchange about already existing software to model particular aspects of optical systems.</li>
<li>Conception of a general system for describing optical systems. This concept would also be helpful as a base for open-science / open-data efforts serving as a metadata standard.</li>
<li>Development of a software platform / framework with the goal to provide clear interfaces (e.g. API or file-based) for the interoperation of the different tools.</li>
<li>(Depending on time constraints), direct implementation of modules within the above framework instead of external interfaces (e.g. geometric optics / raytracing).</li>
<li>(Depending on time constraints), development of intuitive GUI for easy modelling of optical systems.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="project-plan"><a class="header" href="#project-plan">Project plan</a></h1>
<p>For achieving the project goals, the following activities are planned:</p>
<ol>
<li>Survey of the optical aspects the different research groups are interested in while designing laser systems. This would later be the base for the design of a data model structure and should ensure that most (if not all) of the system properties can be mapped.</li>
<li>Survey of existing tools used in the different institutes. The software packages might be collected at a central place (if publically available).</li>
<li>Analysis of the existing tools and the identification of interoperation possibilities</li>
<li>Development of a general data structure for modelling optical systems based on the result of the first point.</li>
<li>Implementation of a framework using this data structure</li>
<li>Implementation of adapters to the already existing tools</li>
<li>Direct development / implementation of (simple) modules fullfilling common aspects of optical systems (such as geometric optical)</li>
<li>Development of GUI</li>
</ol>
<p>Up to now, the points 4, 5 &amp; 6 will be the main activity within the project and will make up the majority of the work to be done.</p>
<p>The implementation of the framework can also be separated in a step-by-step approach:</p>
<ol>
<li>Implementation of basic data structures (OpticScenery, OpticNode, etc..)</li>
<li>Implementation of very basic ideal nodes (Maybe only "source", "detector", "propagation", "ideal beam splitter", "ideal filter")</li>
<li>Above simple nodes would allow a first very simple analysis: energy transmission through a tree-like system. This would allow for first checks of the data structures and general design.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="existing-software"><a class="header" href="#existing-software">Existing Software</a></h1>
<p>The following software already exists in the field of optical simulation and should be considered while designing the model concept.</p>
<h2 id="free--open-source"><a class="header" href="#free--open-source">Free / Open Source</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Software</th><th>Institute</th><th>Contact person</th><th>Language</th><th>comment</th></tr></thead><tbody>
<tr><td>HASEonGPU</td><td>HZDR</td><td>Daniel Albach</td><td>C/C++</td><td>parasitic lasing in high-power laser amplifiers</td></tr>
<tr><td>SHG</td><td>GSI</td><td>Marcus Malki</td><td>Python</td><td>second harmonic generation</td></tr>
<tr><td>SNLO</td><td>free</td><td>-</td><td>Binary (APL or matlab)</td><td>three-wave mixing</td></tr>
<tr><td>LightPipes</td><td>free</td><td>Leonard Doyle</td><td>Python / C++</td><td>Beam propagation Toolbox</td></tr>
<tr><td>Sisyphos</td><td>FFI (Norway)</td><td>Gunnar Arisholm</td><td>Python / C</td><td>parametric amplifiers, spectral broadening, postcompression</td></tr>
<tr><td></td><td>GoLP</td><td>Goncalo Figuera</td><td>?</td><td>spatio-temporal coupling</td></tr>
<tr><td></td><td>LULI</td><td></td><td>?</td><td></td></tr>
<tr><td></td><td>Rochester</td><td></td><td>?</td><td></td></tr>
</tbody></table>
</div>
<h2 id="commercial"><a class="header" href="#commercial">Commercial</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Software</th><th>Institute</th><th>Contact person</th><th>Language</th><th>comment</th></tr></thead><tbody>
<tr><td>GLAD</td><td>HZDR</td><td>Mathias Siebold</td><td>Matlab</td><td>universal modelling of laser amplifier chains</td></tr>
<tr><td>ZEMAX</td><td>commercial</td><td>Udo Eisenbarth</td><td>Binary</td><td>general geometric optics simulation</td></tr>
<tr><td>Commod Pro</td><td>commercial</td><td>D. Kramer</td><td>Binary</td><td>universal modelling of laser amplifier chains</td></tr>
<tr><td>Miro</td><td>LULI</td><td>-</td><td></td><td>universal modelling of laser amplifier chains</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="modelling-optical-systems"><a class="header" href="#modelling-optical-systems">Modelling optical systems</a></h1>
<p>In this chapter we want to develop a general model for describing optical systems. This taks represents a major part of the project. A careful planning of this model is a crucial point, since wrong decisions in the (data) model could lead to severe shortcomings in later real-world problems to be solved. Hence, this also directly influences the acceptance of this work in the community. A model not being used is of course of very little use...</p>
<p>In general, optical systems consist of light sources which provide a more or less complex light field (time invariant or time dependent) and optical components, which modify this light field.  Furthermore, there are light sinks such as simple beam dumps, targets or detectors. These are the elements which produce a "result" (e.g. measurable signal) and thus make a system "productive". The components - light sources (such as a laser) or optical elements (e.g. Faraday isolators) - might itself consist of sub components. In principle, these components again might consist of sub components with an unlimited nesting level.</p>
<p>Of course for a full system description, it would be sufficient to simply place the mechanical model of the optical components in a 3D space along with their particular orientation. For certain tasks, such as illumination or straylight analysis this would be an appropriate approach (and thus will be supported by our model). However, typical systems mostly cast optical rays or light fields in a directed way from one component to the next one. Optical systems can thus be rather decribed in network- or most often in tree-like structures.</p>
<h2 id="directed-graphs-as-primary-model-structure"><a class="header" href="#directed-graphs-as-primary-model-structure">Directed graphs as primary model structure</a></h2>
<p>For the above mentioned networks of optical components, well-established structures could be used which already exist for a long time: <a href="https://en.wikipedia.org/wiki/Directed_graph">directed graphs</a>. A directed graph consists of so-called <em><a href="nodes.html">nodes</a></em> and <em><a href="edges.html">edges</a></em>. For our purposes nodes respresent the optical components, while edges represent the information about the light (energy, wavelength, wavefront, nearfield distribution, etc.) to be handed from one node to the next one. Note, that in this picture, a free space propagation is also represented by a node.</p>
<p>A node has one or more <em>ports</em> where edges can be connected to. We thereby strictly distinguish between incoming and outgoing ports. A node with no input ports represents a light source. Nodes with no output ports are detectors. A simple (ideal) propagation node would have one input and one output port. Furthermpre, an ideal beam splitter has one input port and two or more output ports. More realistic components such as a real lens could also have more than one input and output ports e.g for simulating ghost reflections from lens surfaces.</p>
<p>There are different node types representing various optical components (ideal / real lenses, beam splitters, waveplates, etc.). Each node has, depending on its node type, various attributes, which describe component parameters such as length (e.g. for propagation nodes), focal length (ideal lenses), radii of curvature (real lenses) etc. In addition, there are <em>group nodes</em> which represent a set of other nodes. These nodes are also arranged in a directed graph. In this case non-conected ports form the "externally visible" ports of the group. Of course, the nodes of such a group itself can be group nodes thus allowing for setting up hierarchic, nested structures.</p>
<h2 id="loops-for-modelling-resonators"><a class="header" href="#loops-for-modelling-resonators">Loops for modelling resonators</a></h2>
<p>A directed graph can also model optical resonators by forming loops. This works well for ring resonators but might lead to problems for linear resonators. Let us assume we have the most simple linear cavity consisting of a mirror node, a propagation node, and a second mirror node. Forming a loop here might introduce some ambiguities. While the intented loop would consist of all nodes, a simple "reverse" edge from the second mirror back to the propagation node and then further to the first mirror would actually form three loops: The intended large loop from mirror to mirror ans two smaller loops directly between each mirror and the propagation node (which does not make sense in a real world setup). This becomes even worse for more complex resonators containing additional components (lenses, amplifier rods, etc.).</p>
<p>One way out might be the introduction of <em>reference nodes</em>. A referenece node, as the name says, only contains a reference to another node. So this node exactly behaves like the node it references. This way, a linear resonator could be translated into a corresponding ring resonator.</p>
<p><strong>Note</strong>: Strictly speaking, light in a ring resonator can propagate in both directions (if not suppressed by optical components). Since we have a directed graph, only one direction can be modelled so far. Solutions need to be further <a href="https://git.gsi.de/phelix/rust/opossum/-/issues/2">investigated</a>.</p>
<h2 id="intermediate-data-format"><a class="header" href="#intermediate-data-format">Intermediate data format</a></h2>
<p>While being not yet clear at this stage how to fully describe an optical system using the described graph system we would propose to use simple text files for storing optical models. For this the YAML format seems to be appropriate since it is more or less human readable and allows for comments (in contrast to the JSON format). Furthermore, the standard rust serialization library <code>serde</code> already supports this format. As the software progresses, new features will be added or changed. For this, a version system should be considered stright from the beginning.</p>
<p>A graphical representation could be the usage of the <a href="https://graphviz.org/">graphviz software</a> package. While the proposed rust graph library <code>petgraph</code> already provides some basic export to the graphviz <a href="https://graphviz.org/doc/info/lang.html">.dot files</a> this needs to be extended.</p>
<p>On the long run a graphical (drag &amp; drop) editor would of course the favorable option.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nodes"><a class="header" href="#nodes">Nodes</a></h1>
<p>Nodes form the building blocks of the optical model. Maybe it makes sense to introduce different general node types:</p>
<ol>
<li>
<p>Basic node</p>
<p>This node type represents the lowest level modeling optical components. This category includes all ideal components such as "ideal lens", "ideal filter", "ideal mirror", etc... Furthermore, it can represent an interface between two materials such as a flat or curved surface.</p>
</li>
<li>
<p>Propagation node</p>
<p><em>This might also fall in the first category?</em>. This node represents propagation through a given material. This includes free-space propagation (eg. in air or vacuum).</p>
</li>
<li>
<p>Sequential group node</p>
<p>A sequential group node contains a nested directed graph of basic, propagation or other group nodes. A real lens could be a group node consisting of a (curved) input surface node, a propagation node (inside of the lens), and an exit surface.</p>
</li>
<li>
<p>Non-sequential group node</p>
<p>A non-sequential group contains other nodes (which might still be set up as a graph but do not use the structure) which are simply placed in 3D space. This could be used for simulating flashlamp-pumped systems which need the illumination of a laser rod to be simulated. <em>One has to think about the definition of input and output ports (see later) for these systems.</em></p>
</li>
<li>
<p>Reference node</p>
<p>This node type represents a link to another node. It could be necessary to use reference nodes while modeling loops such as <a href="optical_model.html#loops-for-modelling-resonators">resonators</a>.</p>
</li>
</ol>
<p><strong>Note:</strong> It might be necessary to propagate through a node in a reverse direction (e.g. for back reflection / ghost-focus analysis). Hence each node should have a "reverse" function. In the case of a propagation node, this would be identical. For a basic node, it might change the sign of some properties such as the radius of curvature. For group nodes, the underlying order of sub-nodes has to be reversed. The reference node only needs a qualifier to denote whether the propagation is reversed or not.</p>
<h2 id="ports"><a class="header" href="#ports">Ports</a></h2>
<p>Ports are the connector points between nodes and can be connected by <a href="edges.html">edges</a>. Ports are strictly distinguished as "input_1" and "output_1" ports. Output ports can only be connected to input ports of another node and vice versa while it is forbidden to connect two input or two output ports. In addition, output ports do not need to be connected to other nodes. During analysis, any result will be simply discarded.</p>
<p>Ports have a specific name in order to distinguish them. For example, a beamsplitter cube might have one input port (e.g. named "input_1") and two output ports named "output_1" and "transmitted" for the two outgoing beams.</p>
<p>Nodes with output ports only form the optical sources while nodes containing (usually only one) input source will be called detectors. In most cases, a simulation of the model traverses the graph from all sources to a detector node using all possible paths (see <a href="analyzers.html">Analyzers</a>).</p>
<h2 id="attributes"><a class="header" href="#attributes">Attributes</a></h2>
<p>Each node can have a set of attributes that represent its specific properties. For example, a propagation node contains a propagation length and a material. An ideal lens contains the focal length as an attribute. Each attribute has a name and a strictly defined data type. Attributes may have default values or are completely optional.</p>
<p>In addition, nodes have a set of attributes that are common to all of them. However, all of these attributes are optional (e.g. can be "empty").</p>
<h3 id="common-attributes-for-all-nodes"><a class="header" href="#common-attributes-for-all-nodes">Common attributes for all nodes</a></h3>
<ol>
<li>
<p>Node type</p>
<p>This defines node model such as basic node types (propagation, ideal lens, ideal filter etc..) as well as the type sequential / non-sequential group node. Maybe this is not strictly an attribute but a given rust struct type.</p>
</li>
<li>
<p>Node name</p>
<p>While not strictly necessary it is strongly recommended to assign a name to a node for easier identification. In principle, different nodes can have the same name but this might cause much confusion. Internally the model uses unique IDs for each node in order to distinguish them but these IDs are only internally handled.</p>
</li>
<li>
<p>Component Database ID (optional)</p>
<p>If set, this could be a reference to a (local) component database. It should be considered to also include the database information while exporting the model to a file. If the ID is not set, it would be a "manually configured" component.</p>
</li>
<li>
<p>Material</p>
<p><em>This is strictly necessary only for propagation nodes...</em>
Each optical element consists of a given material. These are mostly different glass materials but could also be metals (i.e. for mirrors) or other substances. Even for free-space propagation nodes a material must be given. This might often be "air" or "vacuum". Since materials have a plethora of attributes and will be used by different nodes within a model, the material will be a reference pointing to a materials database.</p>
<p><strong>Note</strong>: For interoperability, it might not be always a good idea to only have the material properties in a (local) database. If the model data is given to another user, this data might not be found in his (also local) database. Hence it should be possible to attach the actual material data to the model during export. The alternative would be to have a global database...</p>
</li>
<li>
<p>3D location</p>
<p>Each node can have information about its location in 3D space determined as XYZ coordinates with respect to a given global origin. The anchor position of the node depends on the specific node type. This attribute together with the orientation information (see next point) can be used for doing a 3D ray-trace analysis or simply for visualization.</p>
</li>
<li>
<p>3D orientation</p>
<p>Besides the location (see previous point) an optical component has a given orientation in 3D space. This orientation is defined by angles around the axes of the global coordinate system.</p>
</li>
<li>
<p>Aperture shape</p>
<p>Each real-world optical component has a limited physical / mechanical size which also determines the area of incoming light it can handle. Incoming beams farther away from the optical axis than the component's extent will simply be lost during the analysis. Hence, each node can define an aperture with different shapes (mostly circular or rectangular). The exact handling of the aperture is defined by the specific node. Without a given aperture many nodes assume an infinitely large component such that all beams are always caught.</p>
<p><strong>Note</strong>: It might be necessary to extend this to one aperture per input port for asymmetric parts.</p>
</li>
<li>
<p>3D mechanical model</p>
<p>For non-sequential analysis (e.g. ray tracing), a 3D geometric model is necessary. This could be provided as static 3D files (OBJ, STL, etc.) or programmatically derived. For example, the model of a spherical lens could be directly calculated.</p>
</li>
<li>
<p>Surface definitions</p>
<p>For both, sequential and non-sequential analysis, surface properties such as coating or roughness which define the way light will be reflected or propagated through should be defined. <em>This could also be modeled using basic nodes</em></p>
</li>
</ol>
<h2 id="analysis-interface"><a class="header" href="#analysis-interface">Analysis interface</a></h2>
<p>As discussed, the actual calculation is performed by the nodes. The presented framework will only make sure that all necessary input data will be provided. For this, each node has to implement an Analysis function with light data from the incoming edges as parameters. This function can now either directly perform a calculation or call specific external modules (such as C/C++ library code or a Python script).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="source"><a class="header" href="#source">Source</a></h1>
<h2 id="properties"><a class="header" href="#properties">Properties</a></h2>
<p><code>light data</code>
: Definition of the light field of the source. See <a href="nodes/../light_data.html">here</a> for more details.</p>
<p><code>light data iso</code>
: Isometry of the light data field. By defining this isometry it is possible to move a point source with respect to the anchor point of the source.</p>
<p><code>alignment wavelength</code>
: This property defines the wavelength if the single light ray which is used during alignment of the nodes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dummy"><a class="header" href="#dummy">Dummy</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="beam-splitter"><a class="header" href="#beam-splitter">Beam splitter</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="energy-meter"><a class="header" href="#energy-meter">Energy meter</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="node-group"><a class="header" href="#node-group">Node group</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ideal-filter"><a class="header" href="#ideal-filter">Ideal filter</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reflective-grating"><a class="header" href="#reflective-grating">Reflective grating</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reference-node"><a class="header" href="#reference-node">Reference node</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spherical-lens"><a class="header" href="#spherical-lens">Spherical lens</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cylindric-lens"><a class="header" href="#cylindric-lens">Cylindric lens</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spectrometer"><a class="header" href="#spectrometer">Spectrometer</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spot-diagram"><a class="header" href="#spot-diagram">Spot diagram</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wavefront-monitor"><a class="header" href="#wavefront-monitor">Wavefront monitor</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="paraxial-surface"><a class="header" href="#paraxial-surface">Paraxial surface</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fluence-detector"><a class="header" href="#fluence-detector">Fluence detector</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wedge"><a class="header" href="#wedge">Wedge</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mirror"><a class="header" href="#mirror">Mirror</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parabolic-mirror"><a class="header" href="#parabolic-mirror">Parabolic mirror</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="edges"><a class="header" href="#edges">Edges</a></h1>
<p>Edges connect the nodes in the model graph. Edges contain the "light data" which needs to be exchanged between the nodes if analyzed by a <a href="./analyzers.html#sequential-analyzer">sequential analyzer</a>. The content of an edge depends on the type of analysis performed. For geometric optics, it contains an array of ray vectors (position &amp; angle) together with a wavelength and an intensity. For wavefront propagation,, it might contain a 2D complex array representing the nearfield distribution as well as the local phase.</p>
<p>Possible types of data:</p>
<ul>
<li>
<p>Energy / Power flow</p>
<p>For simple calculation of light transmission through an optical network. This would also be a starting point for the software development. An extension could be an array of energies / powers depending on the wavelength (=spectrum). This could also propagate through the network and possibly be transformed using non-linear optics (frequency doubling)</p>
</li>
<li>
<p>Geometric optics propagation</p>
<p>In this case an array of 2D vectors representing the vertical distance from an optical axis and its angle to it. This vector might also be extended by an energy, or a wavelength. Later on, it must be extended by the horizontal information. Furthermore, polarization information could be added using Jones matrices.</p>
</li>
<li>
<p>Wavefront optics propagation</p>
<p>For this kind of simulation, a 2D complex matrix is necessary which simulates the nearfield intensity distribution and the local phase of the wavefront. In addition, would be an array of these matrices depending on the wavelength for simulating polychromatic light. Furthermore, similar to the case of geometric optics, a 2D array of local polarization information could be handled (e.g. simulation of local birefringence effects etc.).</p>
</li>
<li>
<p>Time dependency</p>
<p>It is still not clear how to <a href="https://git.gsi.de/phelix/rust/opossum/-/issues/1">handle time-dependent phenomena</a>...</p>
</li>
</ul>
<p>Of course,, the above information can be stored simultaneously in an edge and transported through the graph.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-optical-materials"><a class="header" href="#using-optical-materials">Using optical materials</a></h1>
<p>As discussed, almost all optical components (except ideal ones) consist of one or more materials. Often for simulations, several material parameters must be known. Since the same material data is shared between different nodes, an infrastructure for handling material parameters is needed. A simple approach could be a text file.</p>
<p>Preferable however is a database that would also allow for shared access between different users from a central server. A common materials database would thus reduce the effort of adding new materials. A draft of the database layout could be as follows:</p>
<p><img src="./images/Materials%20database.png" alt="The database layout" /></p>
<p>This structure allows for an arbitrary number of material parameters to be added with a strictly defined data format. Let's describe the structure in detail:</p>
<h2 id="table-materials"><a class="header" href="#table-materials">Table: materials</a></h2>
<p>This is the central table storing the materials with their name and a reference to a material type (see next section). The actual data table (materialdata) refers to this table for assigning a property(value) to a certain material.</p>
<h2 id="table-materialtypes"><a class="header" href="#table-materialtypes">Table: materialtypes</a></h2>
<p>This is a simple table storing different material types such as "glass", "metal", "gas", "crystal" etc. The purpose is simply to provide a filter to all materials while browsing a (possible) long list of materials. Each material refers to an entry of this table. This means the material belongs to a certain material type.</p>
<h2 id="table-properties"><a class="header" href="#table-properties">Table: properties</a></h2>
<p>This table defines the property names such as "refractive index" or "manufacturer" together with a description field. These properties are connected with one or more data types (see next section) which represent the property value type.</p>
<h2 id="table-datatypes"><a class="header" href="#table-datatypes">Table: datatypes</a></h2>
<p>The data type defines the way the value of a property is represented. This could be a value such as "numeric", "string", "2dData" etc. This information defines how the actual data fields (defined in materialdata) have to be interpreted or parsed.</p>
<h2 id="table-datasources"><a class="header" href="#table-datasources">Table: datasources</a></h2>
<p>This table stores information about where the data was taken from (website, info from the manufacturer, own measurement, etc...)</p>
<h2 id="table-proptypes"><a class="header" href="#table-proptypes">Table: proptypes</a></h2>
<p>This is the connecting table for relating a given property to a set of data types.</p>
<h2 id="table-materialdata"><a class="header" href="#table-materialdata">Table: materialdata</a></h2>
<p>This table stores the actual material properties.</p>
<h1 id="materialdb-software"><a class="header" href="#materialdb-software">Materialdb software</a></h1>
<p>As a first project, the materialdb software has been developed. This software consists of a <a href="https://git.gsi.de/phelix/rust/materialdb_backend">backend</a> and a <a href="https://git.gsi.de/phelix/rust/materialdb_frontend">frontend</a> part.</p>
<p>The backend is written in Rust using the <code>seaorm</code> package for database handling as well as the <code>rocket</code> web framework for the development of a web API. Furthermore, this crate also contains basic functions for accessing the database (read-only so far) from the node system to be developed. For viewing / editing the database a frontend package written in Angular was developed.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="physical-processes-subsystems-and-components"><a class="header" href="#physical-processes-subsystems-and-components">Physical Processes, Subsystems and Components</a></h1>
<p>Modern laser systems are composed of a large number of optical subsystems and individual optical components. For a holistic description of such a system, all these optical components and the structures that are built from these must be modeled. Furthermore, a numerous amount of physical effects/processes must be included to create a realistic view of the full system.</p>
<p>In the following, a, probably not complete, list of relevant effects/processes, subsystems and components for high-intensity lasers will be compiled.</p>
<h2 id="physical-effectsprocesses"><a class="header" href="#physical-effectsprocesses">Physical Effects/Processes</a></h2>
<h3 id="gain"><a class="header" href="#gain">Gain</a></h3>
<p>Obviously, gain modeling of high-intensity lasers is indispensable to design either single amplifier modules or to get useful output predictions of the whole laser facility. Furthermore, spatially, temporally and spectrally dependent gain will alter the dynamics of the beam propagation and is needed for a full description of the laser system. Therefore, several gain models should be on hand for this:</p>
<ul>
<li>Gain as simple multiplicator</li>
<li>Full rate-equation modeling</li>
<li>3-level, 4-level, quasi-three level</li>
<li>Analytic approximations</li>
<li>Saturation effects:
<ul>
<li>Frantz-Nodvik equation</li>
<li>Wavelength-dependent saturation: Homogeneous/Inhomogeneous broadening</li>
<li>Absorption</li>
<li>Spatial Hole Burning</li>
</ul>
</li>
<li>3D, 2D, 1D descriptions</li>
<li>Spatial/Temporal Mode support of the amplifier</li>
</ul>
<p>Simultaneously, effects that may alter or limit the gain and output of an amplifier should be regarded, such as:</p>
<ul>
<li>Amplified Spontaneous Emission</li>
<li>Parasitic Lasing</li>
<li>Parametric Fluorescence</li>
</ul>
<h3 id="second-order-nonlinear-effects"><a class="header" href="#second-order-nonlinear-effects">Second-order nonlinear effects</a></h3>
<p>Second-order nonlinear effects include all processes that result from the response of the second-order susceptibility $\chi^{(2)}$:</p>
<ul>
<li>Second-Harmonic Generation (SHG)</li>
<li>Sum-Frequency Generation (SFG)</li>
<li>Difference-Frequency Generation (DFG)</li>
<li>Optical Rectification (OR)</li>
</ul>
<p>Furthermore, processes that utilize these processes shall be part of the description, such as:</p>
<ul>
<li>Optical Parametric Amplification (OPA)</li>
<li>Optical Parametric Chirped-Pulse Amplification (OPCPA)</li>
<li>Optical Parametric Generation/Oscillation (OPG/OPO)</li>
<li>Spontaneous Parametric Down Conversion (SPDC, Parametric Fluorescence)</li>
<li>Cascaded Mixing effects</li>
<li>THz Generation</li>
</ul>
<p>These effects are typically modeled by solving the nonlinear propagation equation with $\chi^{(2)}$ acting as the source term.</p>
<h3 id="third-order-nonlinear-effects"><a class="header" href="#third-order-nonlinear-effects">Third-order nonlinear effects</a></h3>
<p>Similar to the second-order effects, third-order effects result from the response of the medium, described by the third-order nonlinear susceptibility $\chi^{(3)}$. This nonlinear response is responsible for a variety of effects:</p>
<ul>
<li>Kerr effect
<ul>
<li>Self-Phase Modulation (SPM)</li>
<li>Cross-Phase Modulation (XPM)</li>
<li>Modulational Instability</li>
<li>Self-focusing (Whole beam and small scale)</li>
<li>Two-Photon Absorption</li>
<li>Self-Steepening</li>
</ul>
</li>
<li>Four-Wave Mixing
<ul>
<li>Third Harmonic Generation</li>
<li>Parametric Amplification in fibers</li>
<li>Cross-Polarized Wave Generation</li>
<li>Self-Diffraction</li>
<li>Optical Phase Conjugation</li>
</ul>
</li>
</ul>
<p>While the above-mentioned processes act quasi-instantaneous, delayed nonlinear responses of the medium are also relevant for the description of some processes. The most prominent effects here are:</p>
<ul>
<li>Stimulated Raman Scattering (SRS)</li>
<li>Stimulated Brillouin Scattering (SBS)</li>
</ul>
<h3 id="other-effects"><a class="header" href="#other-effects">Other Effects</a></h3>
<p>Aside from processes that are related to the nonlinear susceptibility of the medium, various other processes exist which may alter the electric field during propagation/amplification. These include:</p>
<ul>
<li>Thermal Effects such as thermal lenses, thermally induced birefringence</li>
<li>Electro-Optic Effects: Pockels Effect, Photorefraction</li>
<li>Acousto-Optic Effects: Deflection or frequency shifts in, e.g., acousto-optic modulators</li>
<li>Gain/Absorption saturation</li>
</ul>
<h2 id="subsystems-of-modern-laser-facilities"><a class="header" href="#subsystems-of-modern-laser-facilities">Subsystems of modern laser facilities</a></h2>
<h3 id="amplifiers"><a class="header" href="#amplifiers">Amplifiers</a></h3>
<p>The most relevant subsystems to create high intensities are the amplifiers of the laser. In modern laser systems, the amplification follows the structure of the "Master-Oscillator Power Amplifier" (MOPA). This means that the amplifiers are linked in succession and the output of a previous amplifier is used as input for the next one. This allows the amplifier chain to be conveniently described by means of nodes, whereby the individual amplifier nodes themselves can be, but do not necessarily have to be, described using a node system.
Nowadays, there are a large number of amplifier types that are implemented in modern laser systems. In the following, several amplifier types and their relevant pumping mechanisms are listed:</p>
<ul>
<li>Fiber-based amplifiers
<ul>
<li>Continuous/pulsed laser diode pumping: Forward, backward, forward + backward</li>
</ul>
</li>
<li>Cavity-based amplifiers
<ul>
<li>Short-Pulse Oscillators (CW pump: e.g. frequency-doubled Nd:YAG)</li>
<li>Regenerative amplifiers (pulsed pumping: flash lamp, laser diode)</li>
<li>Optical parametric oscillators (CW pumping or two coupled resonators)</li>
<li>Thin-Disk amplifiers (same as regenerative amplifier but also CW laser-diode pumping for high repetition rate)</li>
</ul>
</li>
<li>Non-Cavity-based Multi-Pass Amplifiers
<ul>
<li>Relay-imaged multi-pass (pulsed/cw laser diodes)</li>
<li>Non-imaged multi-pass (pulsed/cw laser diodes)</li>
<li>Innoslab Amplifiers (pulsed/cw laser diodes)</li>
</ul>
</li>
<li>Rod Amplifiers (Complex Flash-Lamp Pump geometries)</li>
<li>Slab Amplifiers (Complex Flash-Lamp Pump geometries)</li>
<li>Coherent Beam Combination (no pump)</li>
<li>OPA/uOPA/OPCPA (from cw to narrowband long pulse, broadband long pulse or short pulse pump)</li>
</ul>
<h3 id="beam-transport"><a class="header" href="#beam-transport">Beam Transport</a></h3>
<p>As laser facilities consist of multiple, subsequent amplifier modules, beam transportation is necessary which is typically done via telescopes. Here, certain aspects are of relevance:</p>
<ul>
<li>Magnification</li>
<li>Imaging of the beam: Relay-Imaging</li>
<li>Aberrations</li>
<li>Use for mode matching</li>
<li>Use for diffractive Beam shaping</li>
<li>Transmissive or reflective telescope</li>
<li>Parabola usage</li>
</ul>
<h3 id="stretching-and-compression"><a class="header" href="#stretching-and-compression">Stretching and Compression</a></h3>
<p>To reach highest intensities, the concept of chirped-pulse amplification is typically used which requires temporally stretching the pulses and compressing them after amplification. While the use of gratings for the main stretching and compression modules have prevailed, other systems are nonetheless found in laser systems. Accordingly, various setups should be regarded:</p>
<ul>
<li>Grating stretcher
<ul>
<li>Martinez setup (Unfolded with lenses)</li>
<li>Martinez setup (Unfolded with mirrors)</li>
<li>folded Martinez (Banks)</li>
<li>ffner setup</li>
</ul>
</li>
<li>Grating Compressor
<ul>
<li>Four gratings</li>
<li>Two gratings with a double pass</li>
<li>Two gratings with single pass</li>
</ul>
</li>
<li>Prisms</li>
<li>Grisms</li>
<li>Chirped Fiber/Volume Bragg Gratings</li>
<li>Dispersion-based Fiber Stretcher (long fiber)</li>
<li>Chirped mirror setups</li>
<li>Gires-Tournois Interferometer setups</li>
</ul>
<p>Effects concerning stretching and compression process which should be included are:</p>
<ul>
<li>Calculation of the phase</li>
<li>Misalignment sensitivity</li>
<li>Contrast issues due to Spatiospectral coupling</li>
</ul>
<h3 id="measurement-devices"><a class="header" href="#measurement-devices">Measurement devices</a></h3>
<p>Every laser system relies on constantly doing measurements to observe the quality of the provided pulses/beams. Consequently, holistic simulation software should provide the outcome of the simulation either in a direct, "ideal" way or modulated as measured with a certain device. For example, a measured signal of a photodiode is a convolution of the real input signal with the response function of the diode. Such a response of a device may be specifically calculated for each type of device or even more specific for an exact rebuild of a given device. Below, a list of potential parameters of interest and a list of measurement devices is given.</p>
<ul>
<li>Parameters
<ul>
<li>Energy</li>
<li>Power</li>
<li>Fluence</li>
<li>Intensity</li>
<li>Spectrum</li>
<li>Spectral Phase</li>
<li>Pulse duration</li>
<li>Electric Field</li>
<li>Beam size</li>
<li>Wave front</li>
<li>Temporal Contrast</li>
<li>Spatial Contrast</li>
</ul>
</li>
<li>Measurement Devices
<ul>
<li>Energy Meter</li>
<li>Photo Diode</li>
<li>Camera</li>
<li>Shack-Hartmann Sensor</li>
<li>Spectrometer</li>
<li>FROG, SPIDER, Wizzler</li>
<li>Autocorrelator, Cross-Correlator</li>
<li>Shear Plate</li>
<li>Interferometer setups</li>
</ul>
</li>
</ul>
<h2 id="optical-components"><a class="header" href="#optical-components">Optical Components</a></h2>
<p>Every subsystem is composed of at least one or multiple optical components, which are the basis for the modeling of the whole laser system. Each component itself may be modeled separately and effective values may be used in its simulation node. Alternatively, the whole structure of the component may be modeled to get the most realistic output. For example, a more idealistic lens may contain information about its focal length only and a more thorough lens may use information such as the radius of curvature of all surfaces, its aperture and refractive index profile. In optical systems, a broad variety of different single optical components are used, which however may be classified into several groups:</p>
<ul>
<li>Lenses
<ul>
<li>Spherical, Aspherical, Achromatic, Cylindrical,</li>
<li>Fresnel, Axicon, GRIN, Powel Lens</li>
<li>Microlens array</li>
</ul>
</li>
<li>Mirrors
<ul>
<li>Flat, Curved</li>
<li>Dielectric, Metalic</li>
</ul>
</li>
<li>Beamsplitter
<ul>
<li>Polarizing, Spectral, Pellicle, Polka Dot</li>
</ul>
</li>
<li>Filter
<ul>
<li>Spectral, Polarizing, Neutral density</li>
</ul>
</li>
<li>Dispersive Elements
<ul>
<li>Prisms, gratings, Grisms, fiber gratings</li>
</ul>
</li>
<li>Nonlinear Crystals
<ul>
<li>Uniaxial, Biaxial</li>
</ul>
</li>
<li>Laser Medium</li>
<li>Fiber</li>
<li>Phase plates</li>
<li>Polarization Manipulation
<ul>
<li>Pockels Cell, Faraday Rotator, Wave plates</li>
</ul>
</li>
<li>Apertures
<ul>
<li>Pinholes, Serrated</li>
</ul>
</li>
</ul>
<p>Whether a fixed classification in group nodes is useful still has to be determined.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="model-analysis"><a class="header" href="#model-analysis">Model analysis</a></h1>
<p>Once a model is set up by defining the nodes, assigning specific node parameters, and connecting the nodes with edges, the model is ready to be analyzed / simulated. As already discussed in the introduction, the model could be analyzed in very different ways. One might simulate the system using geometric optics. A very simple analysis might only calculate the power / energy flow through the network. Another analysis would be a full-size Fourier optics propagation. In addition, a 3D raytracing procedure could give insight into illumination or straylight scenarios.</p>
<p>Besides this "direct" simulation of the model, it is possible to simply export the model into a given format suitable for external simulation software (e.g. ZEMAX or GLAD).</p>
<p>The underlying type of analysis fundamentally influences how to work with the model. For an energy flow or geometric analysis the system has to traverse in a particular way through the network in order to stepwise calculate the light field within the edges of the model. In contrast, for a 3D ray-trace analysis, the edges do not play a role at all but the nodes have to be placed at given 3D coordinates and light rays from one or more defined source nodes will be cast into the scene and collected by detector nodes.</p>
<p>For this flexibility, there are several <em>analyzers</em> provided. Note that these analyzers do not necessarily perform any calculations themselves directly but might only be responsible for calling the analysis functions of the nodes. In the following, we want to further discuss the analysis modes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="analyzers"><a class="header" href="#analyzers">Analyzers</a></h1>
<p>An analyzer is a module that "orchestrates" an optics simulation. An analyzer defines, how the model will be treated. There are basically two types of analyzers: Sequential and Non-Sequential. A sequential analyzer traverses the graph in a defined manner and triggers the corresponding calculation defined inside the nodes. In contrast, the non-sequential analyzer does not actually make use of the graph structure (i.e. the relations between the nodes) but only uses the nodes and their corresponding attributes such as 3D coordinates or mechanical model data.</p>
<p><strong>Note</strong>: The use of different analyzers might lead to <a href="https://git.gsi.de/phelix/rust/opossum/-/issues/9">"contradicting" models</a>. For example, one can model a free-space propagation node between two other elements (e.g. two lenses). It can thus define a given geometric length as an attribute. On the other hand, the two lenses might have 3D coordinates with a different distance to each other than defined in the propagation node. In this case, the sequential analysis would simulate another model situation as the non-sequential analyzer...</p>
<h2 id="sequential-analyzer"><a class="header" href="#sequential-analyzer">Sequential Analyzer</a></h2>
<p>A sequential analyzer uses the node relations defined by the edges of the model graph. It would traverse the graph from one or more sources to one or more detector nodes. While traversing, it calls the respective analysis functions of each node. The input data is taken from previously calculated light information stored in the input edges of a node. The node's analysis result will be stored on the output edges.</p>
<p>The analyzer is also responsible for deciding which nodes in a graph must be calculated at all. Sometimes the user is only interested in a part of the optical network and in this case, often not all nodes need to be calculated at all. Furthermore, modifications of the model often do not need a complete recalculation of the graph but use results from earlier simulation runs. Finally, the analyzer could also decide, which nodes do not directly depend on each other. In this case, nodes can be calculated in parallel thus saving time on multi-core CPU computers.</p>
<p>There might be different analyzers available such as:</p>
<ul>
<li>geometric analysis (Matrix optics)</li>
<li>Gauss mode propagation (also matrix based, see LaserCalc)</li>
<li>wavefront propagation (Fourier optics)</li>
<li>simple calculation of energy / power</li>
<li>ghost focus / back reflection analysis</li>
<li>...</li>
</ul>
<p>For each analysis, the corresponding node attributes must be set. For example, a light source node has to define a set of rays with a given position and angle if a geometric analysis is performed. For wavefront propagation, a complex intensity / wavefront matrix must be defined.</p>
<p><strong>Note</strong>: Also in this case the model might contain inconsistent values such as a wavefront that does not fit the set of rays defined. <a href="https://git.gsi.de/phelix/rust/opossum/-/issues/9">How do we deal with this?</a></p>
<h2 id="non-sequential-analyzer"><a class="header" href="#non-sequential-analyzer">Non-sequential Analyzer</a></h2>
<p>A non-sequential analyzer does not make use of the edges for traversing the node network. This is the case for performing a free 3D raytracing analysis of an optical setup located in 3D space. Hence, for using this analyzer all nodes must have information of their location and orientation set by the respective attributes. Otherwise, these nodes are simply skipped in the simulation. One or more light source nodes are used to cast light rays into the scene. Detectors on the other hand can collect all incoming rays for further analysis. For ray casting, each node has to have a 3D mechanical representation and a (maybe default) surface definition.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interfacing-with-external-code"><a class="header" href="#interfacing-with-external-code">Interfacing with external code</a></h1>
<p>The presented project is set up as a <em>simulation platform</em> which means that it only provides the framework / infrastructure to perform complex simulations of optical systems. This can be done in different ways. Once an optical system is modeled as explained before it should basically contain all data necessary to run specific simulation codes. Besides that, the entire network can be exported to files compatible with other simulation systems. This is mostly of interest for closed-source (commercial) software packages such as ZEMAX or GLAD. Fortunately, these software packages have more or less human-readable project files which can be reverse-engineered with not too much effort.</p>
<p>For existing open-source software packages it is important to provide interfaces. So far, two codes could be used as proof-of-principle projects:</p>
<ul>
<li>
<p>SHG software (GSI)</p>
<p>This software simulates the behavior of non-linear crystals for second-harmonic generation. This package is written in Python and could be integrated into an "SHG node". It should be investigated, how the interfacing could be performed. Some preliminary work has been done in the current "play project" <em>opticplay</em>. The external code was called from Rust using the PyO3 library.</p>
</li>
<li>
<p>HASEonGPU (HZDR)</p>
<p>This software package is written in C++ and works on graphic CPUs (using CUDA?). If this project provides an external library (DLL) it would be relatively easy to implement. This has to be investigated.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="software-architecture"><a class="header" href="#software-architecture">Software architecture</a></h1>
<p>This chapter discusses the overall software structure of the OPOSSUM system.</p>
<p>In the first version, we want to concentrate on a framework providing the necessary entities (i.e. structs and traits) in order to model optical systems as <a href="./optical_model.html">previously described</a>. This system would simply require a <code>main</code> function calling the necessary structs. For better debugging purposes, we should already implement an export system to the <code>graphviz</code> package (dot-files) for visualization of the graph structures.</p>
<p>In a further step, a command line tool should be developed to accept a data file containing the model. This requires a proper serialization / deserialization system to be implemented. For this, we would propose a very well-established standard crate <code>serde</code> which can then read and write data in various formats such as JSON or YAML.</p>
<p>For future extension steps, the possibilities of modular design should be investigated in detail. This approach helps to keep the basic framework simple and might improve the integration of external code contributions. Hence, the possibilities of a plugin architecture should be considered.</p>
<p>A topmost-level view could look like this:</p>
<p><img src="./images/overall_architecture.svg" alt="Toplevel architecture" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="opticscenery"><a class="header" href="#opticscenery">OpticScenery</a></h1>
<p>The <code>OpticScenery</code>struct contains the entire model and possibly further metadata (e.g. such as a <code>description</code> field). It should also implement functions serialization / deserialization (which will be forwarded to the corresponding functions of the struct members) which allow for writing / reading an optical system to / from a storage medium.</p>
<p>In addition, it should implement the top-most function to export the graph to the graphwiz foramt for easy visualization. Last but not least it also conatins the top-level <code>analyze</code> function starting the acutal analysis process. The type of analysis has to be given here making use of the well-known strategy pattern.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="opticnode"><a class="header" href="#opticnode">OpticNode</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="opticanalyzer"><a class="header" href="#opticanalyzer">OpticAnalyzer</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usage"><a class="header" href="#usage">Usage</a></h1>
<h2 id="installation-on-linux-ubuntu"><a class="header" href="#installation-on-linux-ubuntu">Installation on Linux (Ubuntu)</a></h2>
<p>For installing / compiling the software besides a rust development environment (see rustup) the following packages must be installed:</p>
<pre><code class="language-bash">sudo apt install build-essential cmake libfontconfig1-dev
</code></pre>
<p>Then the software suite can be tested and installed.</p>
<pre><code class="language-bash">cargo test
cargo build
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="open-questions--ideas"><a class="header" href="#open-questions--ideas">Open questions &amp; Ideas</a></h1>
<p>The content of this page has moved to the <a href="https://git.gsi.de/phelix/rust/opossum/-/issues">issue board of the repository</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="useful-resources"><a class="header" href="#useful-resources">Useful resources</a></h1>
<p>This is a list of programming and documentation resources in no particular order that might be interesting for the model and software development:</p>
<ul>
<li>
<p>Software</p>
<ul>
<li><a href="https://docs.rs/petgraph/latest/petgraph/">petgraph</a>: Rust library for working with graph data structures.</li>
<li><a href="https://graphviz.org/">Graphviz</a>: A software pacakge for visualization of graphs. The <code>petgraph</code>crate already has some basic support for it.</li>
<li><a href="https://superperfundo.dev/articles/ray-tracer-part1">Raytracing example for Rust</a>: Basic tutorial for programming a simple raytraces in rust.</li>
<li><a href="https://www.gnu.org/software/goptical/">Goptical</a>: GNU optical design library. A C++ library which could lead as an idea for simulating geometric optics.</li>
<li><a href="https://www.egui.rs/">egui</a>: Possible candidate for a rust GUI library.</li>
<li><a href="https://lib.rs/rendering">List of rendering libs</a>: A list of rust crates for rendering. Do we need this?</li>
<li><a href="https://fyrox.rs/">Fyrox</a>: Possible candidate to an interactive 3D renderer....actually a game engine.</li>
<li><a href="https://crates.io/crates/uom">uom</a>: Rust crate for dealing with physical dimensions and units.</li>
<li><a href="https://rust-unofficial.github.io/patterns/functional/lenses.html">Rust design patterns</a>: Book of common rust desing patterns.</li>
</ul>
</li>
<li>
<p>Physics</p>
<ul>
<li><a href="https://www.db-thueringen.de/receive/dbt_mods_00042053">Holistic simulation of optical systems</a></li>
</ul>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
